
// Mason Yin's sphere test with three.js
let  polyCounter =0;




  
// input data: clusters, egdes, and labels.
// Later on in the real web site we will read them from json files generated by the web server.
// from the update baby test data:


const g_clusters = [
[[-0.0009455676220575497,-9.926170174018145e-05,0.9999995480243913],
[-0.0009387604359780409,-0.00012844411292005622,0.9999995511153761],
[-0.0008915164740763802,-0.00023770670300335439,0.9999995743468594],
[-0.0008836552389206172,-0.0002499500152679679,0.9999995783391155],
[-0.0007203135843471563,-0.0005697640797766957,0.9999995782585279],
[-0.0005535239433118877,-0.000758975166339587,0.9999995587838733],
[-0.0005244880875679913,-0.0007763772143281101,0.9999995610752372],
[-0.00029398274984302874,-0.0009480450643141351,0.9999995073922281],
[-0.0026127367965296123,-0.0030591767673772826,0.9999919074892246],
[-0.0027695004295720345,-0.0031136284248334247,0.999991317555009],
[-0.0027011641841890783,-0.0032817250148272016,0.9999909669556907],
[-0.002631167565269541,-0.003472307399326546,0.9999905099742538],
[-0.002631167565269541,-0.003472307399326546,0.9999905099742538],
[-0.0027011641841890783,-0.0032817250148272016,0.9999909669556907],
[-0.0027695004295720345,-0.0031136284248334247,0.999991317555009],
[-0.0026127367965296123,-0.0030591767673772826,0.9999919074892246],
[-0.00029398274984302874,-0.0009480450643141351,0.9999995073922281],
[-0.00022962103556758518,-0.0009648068771439987,0.9999995082108141],
[-0.00016780208759984447,-0.0009999480198708817,0.9999994859730764],
[-5.5787176103805203e-05,-0.0010359212874117693,0.9999994618772938],
[3.8859861471272696e-05,-0.001041192349343176,0.9999994572040541],
[5.8842990500974924e-05,-0.0012667489472635702,0.9999991959419803],
[5.8842990500974924e-05,-0.0012667489472635702,0.9999991959419803],
[3.8859861471272696e-05,-0.001041192349343176,0.9999994572040541],
[7.954720292696596e-05,-0.001034961972920839,0.9999994612628335],
[0.0002386857136165105,-0.0010114043820566164,0.9999994600450073],
[0.0005340786816209123,-0.0007346190411682135,0.9999995875473281],
[0.0005578620480571902,-0.0007256364225190735,0.9999995811207711],
[0.0008819222570515598,-0.0005282780026883221,0.9999994715676026],
[0.002776359560061552,-0.0027728479312385335,0.9999923015413387],
[0.002799825736096265,-0.0027825202712235247,0.999992209248046],
[0.00276970035081282,-0.0027904333424386683,0.9999922710909961],
[0.0023503604177672268,-0.0029967444379087006,0.9999927476380419],
[0.000343680245832863,-0.0012680266131232295,0.9999991369958262],
[0.0017451235937567425,-0.0032674376348480237,0.9999931391739371],
[0.0021809368899686423,-0.004131533933501733,0.9999890869112714],
[0.0021809368899686423,-0.004131533933501733,0.9999890869112714],
[0.0017451235937567425,-0.0032674376348480237,0.9999931391739371],
[0.000343680245832863,-0.0012680266131232295,0.9999991369958262],
[0.0023503604177672268,-0.0029967444379087006,0.9999927476380419],
[0.00279367196508517,-0.0031190975662607396,0.9999912332752341],
[0.002815976333860595,-0.0031190771992292703,0.9999911707783786],
[0.0030887922969950075,-0.0030904017805191927,0.9999904543439307],
[0.003115007743882118,-0.0028221090641651386,0.9999911661745745],
[0.003114298222515178,-0.002779550622124564,0.9999912875845071],
[0.0031573351605280434,-0.0027707474215186304,0.9999911770577831],
[0.0031573351605280434,-0.0027707474215186304,0.9999911770577831],
[0.003114298222515178,-0.002779550622124564,0.9999912875845071],
[0.003115007743882118,-0.0028221090641651386,0.9999911661745745],
[0.0030887922969950075,-0.0030904017805191927,0.9999904543439307],
[0.002815976333860595,-0.0031190771992292703,0.9999911707783786],
[0.00279367196508517,-0.0031190975662607396,0.9999912332752341],
[0.0023503604177672268,-0.0029967444379087006,0.9999927476380419],
[0.00276970035081282,-0.0027904333424386683,0.9999922710909961],
[0.002799825736096265,-0.0027825202712235247,0.999992209248046],
[0.002776359560061552,-0.0027728479312385335,0.9999923015413387],
[0.0008819222570515598,-0.0005282780026883221,0.9999994715676026],
[0.0009843930177121875,-0.0002637176600396232,0.9999994807115564],
[0.0009834511787408626,-0.00018311383291810235,0.9999994996464264],
[0.0010121002451404396,-0.00011249869199291961,0.9999994814984347],
[0.0010262721810648005,1.562463159289762e-05,0.9999994732605019],
[0.001008224745979307,0.00012049010143468996,0.9999994844823656],
[0.0009135869101445823,0.0002888476767155901,0.9999995409628833],
[0.0007698228285828781,0.0004028335217543413,0.999999622548912],
[0.0002547973710212286,0.0009075581697011433,0.9999995557081355],
[0.0002467006790282873,0.0009102062002311974,0.9999995553316252],
[0.0012124657540250878,0.0022746140898832626,0.999996678023251],
[0.0027558741967565856,0.002782445823773256,0.9999923315469221],
[0.002779166589070873,0.0027728429469337456,0.9999922937578378],
[0.002941728100216762,0.002301293683405348,0.9999930251172591],
[0.0030947503122454125,0.002665635898884203,0.9999916584180888],
[0.003822838007470585,0.002529689802347478,0.9999894932343403],
[0.003869616063212918,0.0026375259578845715,0.9999890347040535],
[0.0038804603990999307,0.0026560094254500705,0.9999889437593913],
[0.00392672339667344,0.002637751665175967,0.9999888114921681],
[0.00392672339667344,0.002637751665175967,0.9999888114921681],
[0.0038804603990999307,0.0026560094254500705,0.9999889437593913],
[0.003869616063212918,0.0026375259578845715,0.9999890347040535],
[0.003822838007470585,0.002529689802347478,0.9999894932343403],
[0.0030947503122454125,0.002665635898884203,0.9999916584180888],
[0.002941728100216762,0.002301293683405348,0.9999930251172591],
[0.002779166589070873,0.0027728429469337456,0.9999922937578378],
[0.0027558741967565856,0.002782445823773256,0.9999923315469221],
[0.0012124657540250878,0.0022746140898832626,0.999996678023251],
[0.0002467006790282873,0.0009102062002311974,0.9999995553316252],
[0.00023900894722391766,0.0009123727220657568,0.9999995552252707],
[0.00018222512508732794,0.0009590399154081835,0.9999995235181087],
[6.758267108479151e-05,0.0010178274767277072,0.9999994797297698],
[1.7672362157538096e-05,0.0010320423947518666,0.9999994672879496],
[0.0002563654060122722,0.0036138982330040596,0.9999934369866336],
[5.892822080161045e-05,0.005169072584063009,0.9999866385187781],
[0.0005376055374511219,0.005491257483100739,0.999984778419922],
[0.0005376055374511219,0.005491257483100739,0.999984778419922],
[5.892822080161045e-05,0.005169072584063009,0.9999866385187781],
[0.0002563654060122722,0.0036138982330040596,0.9999934369866336],
[1.7672362157538096e-05,0.0010320423947518666,0.9999994672879496],
[-5.393657140366075e-05,0.0010398146782593977,0.9999994579379937],
[-0.00037484265970258543,0.0025186053137977757,0.9999967580548718],
[-0.0015511307751307052,0.004180797764856679,0.9999900574122564],
[-0.002017102286161417,0.0045956000261788135,0.9999874058000764],
[-0.0018457018893969885,0.004809770113742489,0.9999867296599433],
[-0.0016551852631124272,0.005019408800107568,0.9999860328509804],
[-0.0011848698704022848,0.005273576054190861,0.9999853926328078],
[-0.0012335811457422014,0.0054894069050029325,0.9999841722194348],
[-0.0012335811457422014,0.0054894069050029325,0.9999841722194348],
[-0.0011848698704022848,0.005273576054190861,0.9999853926328078],
[-0.0016551852631124272,0.005019408800107568,0.9999860328509804],
[-0.0018457018893969885,0.004809770113742489,0.9999867296599433],
[-0.002017102286161417,0.0045956000261788135,0.9999874058000764],
[-0.0015511307751307052,0.004180797764856679,0.9999900574122564],
[-0.00037484265970258543,0.0025186053137977757,0.9999967580548718],
[-5.393657140366075e-05,0.0010398146782593977,0.9999994579379937],
[-0.00011069239130809566,0.0010359480248665275,0.9999994572792948],
[-0.0003415333750784614,0.0009412359962963882,0.9999994987147509],
[-0.0017691765881606414,0.0025999259096831156,0.9999950551875064],
[-0.002526996735348567,0.003038362665073584,0.9999921912894195],
[-0.002526996735348567,0.003038362665073584,0.9999921912894195],
[-0.0017691765881606414,0.0025999259096831156,0.9999950551875064],
[-0.002755949147892062,0.0027729246649412453,0.9999923577873467],
[-0.002755949147892062,0.0027729246649412453,0.9999923577873467],
[-0.0017691765881606414,0.0025999259096831156,0.9999950551875064],
[-0.0003415333750784614,0.0009412359962963882,0.9999994987147509],
[-0.00040459387347408047,0.0008836668459303396,0.99999952771824],
[-0.00069298690681021,0.0005246393013170079,0.999999622261304],
[-0.0009463204775618237,0.00028987918091295654,0.9999995102236872],
[-0.0009955016968951863,7.561402438096624e-05,0.9999995016293213],
[-0.0013896366758895035,0.0001512313982631511,0.9999990230190094],
[-0.0037795000989164214,0.0024167487081378433,0.999989937301713],
[-0.003090663775184582,0.002675855889410255,0.9999916437614306],
[-0.003111289100153233,0.00275621329439656,0.9999913615468942],
[-0.003111289100153233,0.00275621329439656,0.9999913615468942],
[-0.003090663775184582,0.002675855889410255,0.9999916437614306],
[-0.0037795000989164214,0.0024167487081378433,0.999989937301713],
[-0.0013896366758895035,0.0001512313982631511,0.9999990230190094],
[-0.002123235863516996,0.00031865105421957255,0.9999976951628307],
[-0.004985478971305079,0.0010621677658869174,0.99998700831514],
[-0.0052128089051542295,0.001133809956319398,0.9999857704479106],
[-0.0054900576844898645,1.6223589013464153e-05,0.9999849293881464],
[-0.005593258236281793,9.29814458276481e-06,0.9999843575655806],
[-0.0056301924332149604,0.00039062646708349903,0.9999840740452461],
[-0.0056301924332149604,0.00039062646708349903,0.9999840740452461],
[-0.005593258236281793,9.29814458276481e-06,0.9999843575655806],
[-0.0054900576844898645,1.6223589013464153e-05,0.9999849293881464],
[-0.0052128089051542295,0.001133809956319398,0.9999857704479106],
[-0.004985478971305079,0.0010621677658869174,0.99998700831514],
[-0.002123235863516996,0.00031865105421957255,0.9999976951628307],
[-0.0013896366758895035,0.0001512313982631511,0.9999990230190094],
[-0.0009955016968951863,7.561402438096624e-05,0.9999995016293213],
[-0.00098088080415913,-1.4658833801203348e-05,0.9999995188288676],
[-0.0009720163333812572,-4.2837279678766674e-05,0.9999995266744955],
[-0.0009685982386293351,-5.174178980395433e-05,0.999999529570009],
[-0.0009455676220575497,-9.926170174018145e-05,0.9999995480243913],],
];



const g_edges = [{from: "1", to: "0"},{from: "1", to: "3"},{from: "1", to: "2"},{from: "0", to: "3"},{from: "0", to: "2"},{from: "3", to: "2"},];

const g_labels = [{label: "1", pos: [0.8318300002712806,0.5281427365803921,0.17065784613095156]},{label: "0", pos: [-0.6754526003690585,0.2020385654696156,0.7091855911661322]},{label: "3", pos: [-0.37775296653011853,0.2564986694975723,-0.8896691119869624]},{label: "2", pos: [0.21675832134953718,-0.9762198922211932,-0.0032484084368361588]},];




const tempV = new THREE.Vector3();
const myV = new THREE.Vector3();

const cameraToPoint = new THREE.Vector3();
const cameraPosition = new THREE.Vector3();
const normalMatrix = new THREE.Matrix3();
const settings = {
  minArea: 20,
  maxVisibleDot: -0.2,
};


  const width = 1200
  const height = 700
  const globeRadius = 200
  const globeSegments = 64
  const globeWidth = 4098 / 2
  const globeHeight = 1968 / 2


const clusterColors = [];

//label and position in a dictionary table for efficient access when drawing edges. 
// key: label name
// value: position in V3 and color of the node, which is inverse color of the cluster.
// if node numbers is more than the numbers of clusters, randomize the color of node.
const labelTable = new Object();  



var labels = [];
var scene = new THREE.Scene();


const canvas = document.querySelector('#c');
const renderer = new THREE.WebGLRenderer({canvas});




var camera = new THREE.PerspectiveCamera(45, width / height, 1, 4000);
camera.position.set(0, 5, -500);



renderer.setSize(width, height);

renderer.setClearColor(0x999999);


var controls = new THREE.OrbitControls(camera, renderer.domElement);

scene.add(new THREE.AxesHelper(1));


let sphereRadius = globeRadius;
const loader = new THREE.TextureLoader();
const geometry = new THREE.SphereGeometry(sphereRadius, 64, 32);



const material = new THREE.MeshBasicMaterial({transparent: true, opacity: 0.5,  vertexColors: THREE.FaceColors, wireframe: true });

let sphere = new THREE.Mesh(geometry, material);
scene.add(sphere);


const labelContainerElem = document.querySelector('#labels');

///// Main actions: 
//  draw clusters, labels and nodes, and then edges.

// draw cluster.
g_clusters.forEach(drawPoly);

// now we have color for clusters, so prepare label hash table and node color
prepareLabels();

//time for nodes and labels
g_labels.forEach(drawLabelAndNode);

// finally the edges.
g_edges.forEach(drawArcForItem);


function prepareLabels()
{
  for (var i=0; i< g_labels.length; i++)
  {
    var labelName = g_labels[i].label;

    var nodeColor;
    if (i < clusterColors.length)
    {
      nodeColor = invertColor(clusterColors[i]);
    }
    else
    {
      nodeColor = getRandomColor();
    }

    var posi = g_labels[i].pos;
    var tempV = new THREE.Vector3(posi[0], posi[1], posi[2]).normalize().multiplyScalar(sphereRadius);

    var posAndColor = {pos: tempV, color: nodeColor};

    labelTable[labelName] = posAndColor;

  }
}

function drawLabelAndNode (data, index, array)
{
  var v3Pos = labelTable[data.label].pos;
  drawLabelAt(v3Pos,  data.label);
  spot(v3Pos, labelTable[data.label].color);

}


function spot(point, color) {
  var s = new THREE.Mesh(new THREE.SphereGeometry(3, 32, 24), new THREE.MeshBasicMaterial({
    color: color
  }));
  s.position.copy(point);
  scene.add(s);
  return s;
}


function spot2(point, color) {
  var s = new THREE.Mesh(new THREE.SphereGeometry(5, 32, 24), new THREE.MeshBasicMaterial({
    color: color
  }));
  s.position.copy(point);
  //scene.add(s);
  return s;
}



function drawLabel (node, index, array)
{
  var tempV = new THREE.Vector3(node.pos[0], node.pos[1], node.pos[2]).normalize().multiplyScalar(sphereRadius);
  var meshPoint = spot(tempV, 0xff0000);
  
  const elem = document.createElement('div');
    elem.textContent = node.label;
    labelContainerElem.appendChild(elem);

    labels.push({elem, meshPoint});

   
}

function drawLabelAt (v3Pos, txt)
{
  
  var meshPoint = spot2(v3Pos, 0xff0000);
  
  const elem = document.createElement('div');
    elem.textContent = txt;
    labelContainerElem.appendChild(elem);

    labels.push({elem, meshPoint});

   
}

function drawArcForItem (edge, index, array)
{

  var fromKey = edge.from.trim();
  var toKey = edge.to.trim();
  if (fromKey in labelTable  && toKey in labelTable)
  {
    var v3Start = labelTable[fromKey].pos;
    var v3End = labelTable[toKey].pos;
    setShortArc(v3Start, v3End, 20, "white");
  }
  
}

function setArc3D(pointStart, pointEnd, smoothness, color, clockWise) {
  // calculate normal
  var cb = new THREE.Vector3(),
    ab = new THREE.Vector3(),
    normal = new THREE.Vector3();
  cb.subVectors(new THREE.Vector3(), pointEnd);
  ab.subVectors(pointStart, pointEnd);
  cb.cross(ab);
  normal.copy(cb).normalize();

  // get angle between vectors
  var angle = pointStart.angleTo(pointEnd);
  if (clockWise) angle = angle - Math.PI * 2;
  var angleDelta = angle / (smoothness - 1);

  var geometry = new THREE.Geometry();
  for (var i = 0; i < smoothness; i++) {
    geometry.vertices.push(pointStart.clone().applyAxisAngle(normal, angleDelta * i))
  }

  var arc = new THREE.Line(geometry, new THREE.LineBasicMaterial({
    color: color, linewidth: 3.0
  }));
  return arc;
}


function GetSmoothness(pointStart, pointEnd)
{
  // we use 0.5 degree as the divider.
  var angleInterval = 1.0; 
  var cb = new THREE.Vector3(),
    ab = new THREE.Vector3(),
    normal = new THREE.Vector3();
  cb.subVectors(new THREE.Vector3(), pointEnd);
  ab.subVectors(pointStart, pointEnd);
  cb.cross(ab);
  normal.copy(cb).normalize();

  // get angle between vectors
  var angle = pointStart.angleTo(pointEnd);
  if (Math.abs(angle) > Math.abs(angle - Math.PI*2))
  {
    angle = angle - Math.PI * 2;
  }

  if (Math.abs(angle)*(180.0/Math.PI) < angleInterval)
  {
    return 2;
  }

   var smoothness = (Math.abs(angle) * 180/Math.PI)/angleInterval;
    smoothness = Math.floor(smoothness);
    if (smoothness < 2)
    {
      smoothness =2;
    }

    return smoothness;
}

function setShortArc(pointStart, pointEnd, smoothness, color) {
  // calculate normal
 
  var cb = new THREE.Vector3(), ab = new THREE.Vector3(), normal = new THREE.Vector3();
  cb.subVectors(new THREE.Vector3(), pointEnd);
  ab.subVectors(pointStart, pointEnd);
  cb.cross(ab);
  normal.copy(cb).normalize();
  // get angle between vectors
  var angle = pointStart.angleTo(pointEnd);
  //////////
  if (Math.abs(angle) < (Math.PI / 180)) {
    smoothness = 2;
  }
  else {
    smoothness = Math.abs(angle) * 180 / Math.PI;
    smoothness = Math.floor(smoothness);
    if (smoothness < 2) {
      smoothness = 2;
    }
  }
  //////
  if (Math.abs(angle) > Math.abs(angle - Math.PI * 2)) {
    angle = angle - Math.PI * 2;
  }
  var angleDelta = angle / (smoothness - 1);
  var geometry = new THREE.Geometry();
  for (var i = 0; i < smoothness; i++) {
    var v3 = pointStart.clone().applyAxisAngle(normal, angleDelta * i);
    
    geometry.vertices.push(v3);
  }
  var arc = new THREE.Line(geometry, new THREE.LineBasicMaterial({
    color: color, linewidth: 3.0
  }));
  scene.add(arc);
  }



function setArcGetGeoPoints(pointStart, pointEnd, smoothness, color) {
  // calculate normal
  var geoPoints = [];
  var cb = new THREE.Vector3(), ab = new THREE.Vector3(), normal = new THREE.Vector3();
  cb.subVectors(new THREE.Vector3(), pointEnd);
  ab.subVectors(pointStart, pointEnd);
  cb.cross(ab);
  normal.copy(cb).normalize();
  // get angle between vectors
  var angle = pointStart.angleTo(pointEnd);
  //////////
  if (Math.abs(angle) < (Math.PI / 180)) {
    smoothness = 2;
  }
  else {
    smoothness = Math.abs(angle) * 180 / Math.PI;
    smoothness = Math.floor(smoothness);
    if (smoothness < 2) {
      smoothness = 2;
    }
  }
  //////
  if (Math.abs(angle) > Math.abs(angle - Math.PI * 2)) {
    angle = angle - Math.PI * 2;
  }
  var angleDelta = angle / (smoothness - 1);
  var geometry = new THREE.Geometry();
  for (var i = 0; i < smoothness; i++) {
    var v3 = pointStart.clone().applyAxisAngle(normal, angleDelta * i);
    var latLon = vector3toLonLat(v3.clone());
    geoPoints.push(latLon);
    geometry.vertices.push(v3);
  }
  var arc = new THREE.Line(geometry, new THREE.LineBasicMaterial({
    color: color, linewidth: 3.0
  }));
  return [arc, geoPoints];
  }


function getArcPoints (pointStart, pointEnd, smoothness)
{
  var points = [];
  if (smoothness < 3)
  {
    points.push(pointStart);
    points.push(pointEnd);

  }
  else
  {
    var cb = new THREE.Vector3(),
    ab = new THREE.Vector3(),
    normal = new THREE.Vector3();
    cb.subVectors(new THREE.Vector3(), pointEnd);
    ab.subVectors(pointStart, pointEnd);
    cb.cross(ab);
    normal.copy(cb).normalize();

    // get angle between vectors
    var angle = pointStart.angleTo(pointEnd);
    if (Math.abs(angle) > Math.abs(angle - Math.PI*2))
    {
      angle = angle - Math.PI * 2;
    }

    var  angleDelta = angle / (smoothness - 1);
  

  
    for (var i = 0; i < smoothness; i++)
     {
      var v3 = pointStart.clone().applyAxisAngle(normal, angleDelta * i);
      points.push(v3);
     }
     

  }
  return points;

}

//////////////
function pointInTriangle (position,coord1,coord2,coord3){
  
  
  var d1,d2,d3;
  var m1 = new THREE.Matrix3();
 m1.set(position.x, position.y, position.z, coord2.x, coord2.y, coord2.z, coord3.x, coord3.y, coord3.z );
 d1 = m1.determinant();

 
  var m2 = new THREE.Matrix3();
  m2.set(coord1.x, coord1.y, coord1.z, position.x, position.y, position.z, coord3.x, coord3.y, coord3.z);
  d2 = m2.determinant();

  
  var m3 = new THREE.Matrix3();
  m3.set(coord1.x, coord1.y, coord1.z, coord2.x, coord2.y, coord2.z, position.x, position.y, position.z);
  d3 = m3.determinant();

  if((d1>=0 && d2 >=0 && d3>=0) || (d1<=0 && d2 <=0 && d3<=0)){
      return true;
  }
  return false;
}


function randColorPoly (poly, index, array)
{
   if (poly.length < 3)
   {
     return
   }

   var points = [];
   for (var i=0; i< poly.length; i++)
   {
    var tempV = new THREE.Vector3(poly[i][0],poly[i][1], poly[i][2]).normalize().multiplyScalar(sphereRadius);
    points.push(tempV);
   }
   drawPolygon(points, getRandomColor());
}

function drawPoly ( poly, index, array)
{
  var clr = getRandomColor();
  clusterColors.push(clr);

  drawPolyAzimuthal(poly,clr)
  polyCounter++;
}

function v3toGeoArray (points)  // not Vector3
{
  var geoArray = [];
  for (var i=0; i< points.length; i++)
  {
    var temp = new THREE.Vector3(points[i][0], points[i][1], points[i][2]).normalize();
    var geoPoint = vector3toLonLat(temp);
    geoArray.push(geoPoint);
  }
  return geoArray;

}

function v3toGeoAndThreeArray (points)  // not Vector3
{
  var geoArray = [];
  var ThreeArray =[];
  for (var i=0; i< points.length; i++)
  {
    var temp = new THREE.Vector3(points[i][0], points[i][1], points[i][2]).normalize();
    var threeV = temp.clone().multiplyScalar(sphereRadius);
    ThreeArray.push(threeV);
    var geoPoint = vector3toLonLat(temp);
    geoArray.push(geoPoint);
  }
  return [geoArray, ThreeArray];

}


function testDrawPolyEarcut()
{
  var geoRectangle = [ [90, 10], [110, 20], [100, 40], [115, 25], [160, 50], [-160, 50], [150, 10], [145, 40], [120, 20], [130, 10]];
  var v3points = [];
  for (var i=0; i < geoRectangle.length; i++)
  {
    var vct3 = lonLatToVector3(geoRectangle[i][0], geoRectangle[i][1]);
    var v3 = [vct3.x, vct3.y, vct3.z];
    v3points.push(v3);
  }

  // test getCross180LatFromLonLat (lon0, lat0, lon1, lat1)
 var ret = getCross180LatFromLonLat (160, 70, -150, 50);
  //var splitPolys = cutAlong180(geoRectangle);

  drawPolyEarcut2(v3points, getRandomColor());
}


function testDrawPolyEarcut3()
{
  var geoRectangle = [ [90, 10], [110, 20], [100, 40], [115, 25], [160, 50], [-160, 50], [150, 10], [145, 40], [120, 20], [130, 10]];

   var tmp2 = azimuthalProjection (geoRectangle);
  var v3points = [];
  for (var i=0; i < geoRectangle.length; i++)
  {
    var vct3 = lonLatToVector3(geoRectangle[i][0], geoRectangle[i][1]);
    drawLabelAt(vct3.clone().normalize().multiplyScalar(sphereRadius), i.toString());
   
    //var v3 = [vct3.x, vct3.y, vct3.z];
    v3points.push(vct3);
  }

  // test getCross180LatFromLonLat (lon0, lat0, lon1, lat1)
 //var ret = getCross180LatFromLonLat (160, 70, -150, 50);
  //var splitPolys = cutAlong180(geoRectangle);

  drawPolyEarcut3(v3points, getRandomColor());
  
}

function triFaceInside ( a, b, c)
{
  var ac = c.clone().sub(a.clone()).normalize();
  var ab = b.clone().sub(a.clone()).normalize();
  var normal = ac.cross(ab).normalize();
  var final = normal.add(a.clone().normalize());
  if (final.length() < 1)
  {
    return true;
  }
  return false;

}
/**
 * 
 * @param {*} points : THREE.JS Vector3 normalized array, in clockwise order.
 */
function earcut3d (points) 
{
   var ret =[];
  
    var remain =[];
    for (var x=0; x< points.length; x++)
    {
      remain.push(x);
    }

    while (remain.length > 3)
    { 
      var newRemain = [];
      for (var i=0; i< remain.length-2; )
      {
        var a = remain[i];
        var b = remain[i+1];
        var c = remain[i+2];
        newRemain.push(a);
        // for a, b, c triangle.
        // remove same points and point in a straight line

        /****
         *     c
         *   b
         *     a
         */
        var  ba = points[a].clone().sub(points[b].clone()).normalize();
        if (isZero(ba))
        {
          i +=2;
          continue; // drop point b
        }
        var bc = points[c].clone().sub(points[b].clone()).normalize();
        if (isZero(bc))
        {
          i +=2;
          continue;  // drop b
        }

        var cross = ba.cross(bc).normalize();;
        if (isZero(cross))
        {
          i +=2;
          continue; // drop b, straigt line.
        }

        var addV = cross.add(points[b].clone().normalize());

        if (addV.length() > 1)
        {
          // cut it
          // clockwise
          ret.push(a); ret.push(b); ret.push(c);
          i +=2;
        }
        else
        {
          // can't cut
          //newRemain.push(b);
          i++;
        }

      }

      // push the last one/two points for next round
      while (i < remain.length)
      {
        newRemain.push(i);
        i++;
      }

      remain = newRemain;
    }

    // 3 points remaining, figure out clock wise or not
    var fa = remain[0];
    var fb = remain[1];
    var fc = remain[2];
    var  fba = points[fa].clone().sub(points[fb].clone());
    if (isZero(fba))
    {
      // does not matter clockwise or not, straight line anyway
      ret.push(fa);
      ret.push(fb);
      ret.push(fc);
      return ret;
    }
    var fbc = points[fc].clone().sub(points[fb].clone());
    if (isZero(fbc))
    {
      // does not matter clockwise or not, straight line anyway
      ret.push(fa);
      ret.push(fb);
      ret.push(fc);
      return ret;
    }

    var fcross = fba.cross(fbc).normalize();
    if (isZero(fcross))
    {
      // does not matter clockwise or not, straight line anyway
      ret.push(fa);
      ret.push(fb);
      ret.push(fc);
      return ret;
    }

    if (fcross.add(points[fb]).length() > 1)
    {
     
      // clockwise
      ret.push(fa); ret.push(fb); ret.push(fc);
    }
    else
    {
      //counter clockwise
      ret.push(fa); ret.push(fc);  ret.push(fb);
    }

    return ret;


  


}

function isZero (v3)
{
  if ( v3.length() < 0.0001)
  {
    return true;
  }
  return false;
}

function checkClockWise (points)
{
  var sum = 0.0;
  for (var i=0; i< points.length-1; i++)
  {
     sum += (points[i+1][1] - points[i][1])*(points[i+1][0] + points[i][0]);
  }

  if (sum > 0)
  {
    return true;
  }
  return false;
}

function azimuthalProjection (geoPoints, theColor="")
{
  var geoPolyformat = {type: "Polygon", coordinates: [geoPoints]};
   
  var c = d3.geoCentroid(geoPolyformat);
    
  // for debuging only comment out later///////////////
  //plot out the center with Polygon cluster number:
  /*
  var ctr = lonLatToVector3(c[0], c[1]).normalize();
  var centerV3 = ctr.clone().multiplyScalar(sphereRadius);
  var ctrForLine = ctr.clone().multiplyScalar(sphereRadius + 2);
   
  ////// to be commented out /////////////
  if (polyCounter < gNodes.length )
  {  var lbl = gNodes[polyCounter].label;
    if (polyCounter != 20  && polyCounter != 41)
    { 
      if ((lbl != "Modest Mouse")  && (lbl != "Aerosmith"))
      {
        gLabelTable[lbl] = ctrForLine;
      // drawLabelAt (centerV3, polyCounter.toString());
        drawLabelAt (centerV3, lbl);
        var nodeColor = invertColor(theColor);
        spot(centerV3, nodeColor);
      }
    }
  }
  else
  {
  drawLabelAt (centerV3, polyCounter.toString());
  }
  ////////////// to be comment out above /////////////////
  ***/



  var projection = d3.geoAzimuthalEquidistant().rotate([-c[0], -c[1]]);
  var ret =[];

  for (var i=0; i< geoPoints.length; i++)
  {
    var p = projection(geoPoints[i]);
    ret.push(p);
  }

  return ret;
} 


function drawPolyEarcut (points, theColor, )
{
  var geoArray = v3toGeoArray (points);

 

  var wrapper =[];
  wrapper.push(geoArray);
  //wrapper.push(points);
  var data = earcut.flatten(wrapper);
  var triangles = earcut(data.vertices, data.holes, data.dimensions); // the output triangles seem to be clockwise.

  var c = -1; // the counter

  const polyGeometry = new THREE.Geometry();

  for ( var i=0; i <= triangles.length -3; i += 3)
  {
    // clock wise triangle
    /*************
        tb--------tc 
        \       /
          \   /
             ta
            
    ************/
    var ia = triangles[i]; 
    var ib = triangles[i+1];
    var ic = triangles[i+2];

    

    var ta = new THREE.Vector3(points[ia][0],points[ia][1], points[ia][2]).normalize().multiplyScalar(sphereRadius);
    var tb = new THREE.Vector3(points[ib][0],points[ib][1], points[ib][2]).normalize().multiplyScalar(sphereRadius);
    var tc = new THREE.Vector3(points[ic][0],points[ic][1], points[ic][2]).normalize().multiplyScalar(sphereRadius);

    // push ta into the vertice array
    c++;
    polyGeometry.vertices.push(ta);
    var taCounter = c;

    var smooth = GetSmoothness(tb, tc);  // cut line between tb and tc into smaller arcs
    var sectionPoints = getArcPoints(tb, tc, smooth);

    for (var j =0; j< smooth - 1; j++)
    {
      var cordSmooth =  GetSmoothness (ta, sectionPoints[j]);
      var cordPointsAb = getArcPoints(ta, sectionPoints[j], cordSmooth);
      var cordPointsAc = getArcPoints(ta, sectionPoints[j+1], cordSmooth);
      
      for (var k =0; k < cordSmooth; k++)
      {
        polyGeometry.vertices.push(cordPointsAb[k].normalize().multiplyScalar(sphereRadius));
        c++;
        polyGeometry.vertices.push(cordPointsAc[k].normalize().multiplyScalar(sphereRadius));
        c++;

        if (k == 0)
        {
         // polyGeometry.faces.push( new THREE.Face3 (taCounter, c, c-1));   //Face3 needs counter clockwise points
          polyGeometry.faces.push( new THREE.Face3 (taCounter, c-1, c));   //Face3 needs  clockwise points?
        }
        else
        {
          //polyGeometry.faces.push( new THREE.Face3 (c-3, c-2, c));  //counter clockwise
          polyGeometry.faces.push( new THREE.Face3 (c-3, c, c-2));  // clockwise

         // polyGeometry.faces.push( new THREE.Face3 (c-3, c, c -1));  // counter clockwise
          polyGeometry.faces.push( new THREE.Face3 (c-3, c-1, c));  // clockwise

        }
      }
    }
  }  // end of for ( var i=0; i < triangles.length -3; i += 3)

  const polyMaterial = new THREE.MeshBasicMaterial(
    {color: theColor,
     /* wireframe: true,   */
      vertexColors: THREE.FaceColors
    });

  const myPoly = new THREE.Mesh(polyGeometry, polyMaterial);
  scene.add(myPoly);  

}


function invertColor(hex) {
  if (hex.indexOf('#') === 0) {
      hex = hex.slice(1);
  }
  // convert 3-digit hex to 6-digits.
  if (hex.length === 3) {
      hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
  }
  if (hex.length !== 6) {
      throw new Error('Invalid HEX color.');
  }
  // invert color components
  var r = (255 - parseInt(hex.slice(0, 2), 16)).toString(16),
      g = (255 - parseInt(hex.slice(2, 4), 16)).toString(16),
      b = (255 - parseInt(hex.slice(4, 6), 16)).toString(16);
  // pad each with zeros and return
  return '#' + padZero(r) + padZero(g) + padZero(b);
}

function padZero(str, len) {
  len = len || 2;
  var zeros = new Array(len).join('0');
  return (zeros + str).slice(-len);
}


function drawPolyEarcut3 (points, theColor)
{
  
  var triangles = earcut3d(points);
  
  var c = -1; // the counter

  const polyGeometry = new THREE.Geometry();

  for ( var i=0; i <= triangles.length -3; i += 3)
  {
    // clock wise triangle
    /*************
        tb--------tc 
        \       /
          \   /
            ta
            
    ************/
    var ia = triangles[i]; 
    var ib = triangles[i+1];
    var ic = triangles[i+2];

    

    var ta = points[ia].clone().normalize().multiplyScalar(sphereRadius);
    var tb =points[ib].clone().normalize().multiplyScalar(sphereRadius);
    var tc =points[ic].clone().normalize().multiplyScalar(sphereRadius);

    // push ta into the vertice array
    c++;
    polyGeometry.vertices.push(ta);
    var taCounter = c;

    var smooth = GetSmoothness(tb, tc);  // cut line between tb and tc into smaller arcs
    var sectionPoints = getArcPoints(tb, tc, smooth);

    for (var j =0; j< smooth - 1; j++)
    {
      var cordSmooth =  GetSmoothness (ta, sectionPoints[j]);
      var cordPointsAb = getArcPoints(ta, sectionPoints[j], cordSmooth);
      var cordPointsAc = getArcPoints(ta, sectionPoints[j+1], cordSmooth);
      
      for (var k =0; k < cordSmooth; k++)
      {
        polyGeometry.vertices.push(cordPointsAb[k].normalize().multiplyScalar(sphereRadius));
        c++;
        polyGeometry.vertices.push(cordPointsAc[k].normalize().multiplyScalar(sphereRadius));
        c++;

        if (k == 0)
        {
        // polyGeometry.faces.push( new THREE.Face3 (taCounter, c, c-1));   //Face3 needs counter clockwise points
          polyGeometry.faces.push( new THREE.Face3 (taCounter, c-1, c));   //Face3 needs  clockwise points?
        }
        else
        {
          //polyGeometry.faces.push( new THREE.Face3 (c-3, c-2, c));  //counter clockwise
          polyGeometry.faces.push( new THREE.Face3 (c-3, c, c-2));  // clockwise

        // polyGeometry.faces.push( new THREE.Face3 (c-3, c, c -1));  // counter clockwise
          polyGeometry.faces.push( new THREE.Face3 (c-3, c-1, c));  // clockwise

        }
      }
    }
  }  // end of for ( var i=0; i < triangles.length -3; i += 3)

  const polyMaterial = new THREE.MeshBasicMaterial(
    {color: theColor,
      wireframe: true,   
      vertexColors: THREE.FaceColors
    });

  const myPoly = new THREE.Mesh(polyGeometry, polyMaterial);
  scene.add(myPoly);  
  

  
}


function drawPolyAzimuthal (gPoints, theColor, )
{
  var conv = v3toGeoAndThreeArray (gPoints);
  var geoArray = conv[0];
  var points = conv[1];
  var aziArray = azimuthalProjection (geoArray, theColor);

  // debugging only: did not work
  //var clockwise = checkClockWise(aziArray);
  //console.log(clockwise);
  ////////////

 
    

    var wrapper =[];
    wrapper.push(aziArray);
  
    var data = earcut.flatten(wrapper);
    var triangles = earcut(data.vertices, data.holes, data.dimensions); // the output triangles seem to be clockwise.

    var c = -1; // the counter

    const polyGeometry = new THREE.Geometry();

    for ( var i=0; i <= triangles.length -3; i += 3)
    {
      // clock wise triangle
      /*************
          tb--------tc 
          \       /
            \   /
              ta
              
      ************/
      var ia = triangles[i]; 
      var ib = triangles[i+1];
      var ic = triangles[i+2];

      

      var ta = points[ia];
      var tb =points[ib];
      var tc =points[ic];


      // test out wrong clockwise direction.
       if (triFaceInside (ta, tb, tc) )
       {
         // switch tb, tc
         tb = points[ic];
         tc = points[ib];
       }

      // push ta into the vertice array
      c++;
      polyGeometry.vertices.push(ta);
      var taCounter = c;

      var smooth = GetSmoothness(tb, tc);  // cut line between tb and tc into smaller arcs
      var sectionPoints = getArcPoints(tb, tc, smooth);

      for (var j =0; j< smooth - 1; j++)
      {
        var cordSmooth =  GetSmoothness (ta, sectionPoints[j]);
        var cordPointsAb = getArcPoints(ta, sectionPoints[j], cordSmooth);
        var cordPointsAc = getArcPoints(ta, sectionPoints[j+1], cordSmooth);
        
        for (var k =0; k < cordSmooth; k++)
        {
          polyGeometry.vertices.push(cordPointsAb[k].normalize().multiplyScalar(sphereRadius));
          c++;
          polyGeometry.vertices.push(cordPointsAc[k].normalize().multiplyScalar(sphereRadius));
          c++;

          if (k == 0)
          {
            polyGeometry.faces.push( new THREE.Face3 (taCounter, c, c-1));   //Face3 needs counter clockwise points
           // polyGeometry.faces.push( new THREE.Face3 (taCounter, c-1, c));   //Face3 needs  clockwise points?
          }
          else
          {
            polyGeometry.faces.push( new THREE.Face3 (c-3, c-2, c));  //counter clockwise
           // polyGeometry.faces.push( new THREE.Face3 (c-3, c, c-2));  // clockwise

             polyGeometry.faces.push( new THREE.Face3 (c-3, c, c -1));  // counter clockwise
            //polyGeometry.faces.push( new THREE.Face3 (c-3, c-1, c));  // clockwise

          }
        }
      }
    }  // end of for ( var i=0; i < triangles.length -3; i += 3)

    const polyMaterial = new THREE.MeshBasicMaterial(
      {color: theColor,
       /*wireframe: true,   */
        vertexColors: THREE.FaceColors
      });

    const myPoly = new THREE.Mesh(polyGeometry, polyMaterial);
    scene.add(myPoly);  
  

}

function drawPolyEarcut2 (gPoints, theColor, )
{
  var geoArray = v3toGeoArray (gPoints);

  var splitPolysBig = cutAlong180(geoArray);
  var splitPolys = [];
  for (var xx=0; xx < splitPolysBig.length; xx++)
  {
    splitPolys = splitPolys.concat(slicePoly(splitPolysBig[xx], 90));
  }

  for (var q=0; q< splitPolys.length; q++)
  {
    //test color
    theColor = getRandomColor();


    var points = [];
    for (var t=0; t< splitPolys[q].length; t++)
    {
      var tmp = lonLatToVector3(splitPolys[q][t][0], splitPolys[q][t][1] ).normalize().multiplyScalar(sphereRadius);
      points.push(tmp);
    }

    var wrapper =[];
    wrapper.push(splitPolys[q]);
    //wrapper.push(points);
    var data = earcut.flatten(wrapper);
    var triangles = earcut(data.vertices, data.holes, data.dimensions); // the output triangles seem to be clockwise.

    var c = -1; // the counter

    const polyGeometry = new THREE.Geometry();

    for ( var i=0; i <= triangles.length -3; i += 3)
    {
      // clock wise triangle
      /*************
          tb--------tc 
          \       /
            \   /
              ta
              
      ************/
      var ia = triangles[i]; 
      var ib = triangles[i+1];
      var ic = triangles[i+2];

      

      var ta = points[ia];
      var tb =points[ib];
      var tc =points[ic];

      // push ta into the vertice array
      c++;
      polyGeometry.vertices.push(ta);
      var taCounter = c;

      var smooth = GetSmoothness(tb, tc);  // cut line between tb and tc into smaller arcs
      var sectionPoints = getArcPoints(tb, tc, smooth);

      for (var j =0; j< smooth - 1; j++)
      {
        var cordSmooth =  GetSmoothness (ta, sectionPoints[j]);
        var cordPointsAb = getArcPoints(ta, sectionPoints[j], cordSmooth);
        var cordPointsAc = getArcPoints(ta, sectionPoints[j+1], cordSmooth);
        
        for (var k =0; k < cordSmooth; k++)
        {
          polyGeometry.vertices.push(cordPointsAb[k].normalize().multiplyScalar(sphereRadius));
          c++;
          polyGeometry.vertices.push(cordPointsAc[k].normalize().multiplyScalar(sphereRadius));
          c++;

          if (k == 0)
          {
          // polyGeometry.faces.push( new THREE.Face3 (taCounter, c, c-1));   //Face3 needs counter clockwise points
            polyGeometry.faces.push( new THREE.Face3 (taCounter, c-1, c));   //Face3 needs  clockwise points?
          }
          else
          {
            //polyGeometry.faces.push( new THREE.Face3 (c-3, c-2, c));  //counter clockwise
            polyGeometry.faces.push( new THREE.Face3 (c-3, c, c-2));  // clockwise

          // polyGeometry.faces.push( new THREE.Face3 (c-3, c, c -1));  // counter clockwise
            polyGeometry.faces.push( new THREE.Face3 (c-3, c-1, c));  // clockwise

          }
        }
      }
    }  // end of for ( var i=0; i < triangles.length -3; i += 3)

    const polyMaterial = new THREE.MeshBasicMaterial(
      {color: theColor,
       /*wireframe: true,   */
        vertexColors: THREE.FaceColors
      });

    const myPoly = new THREE.Mesh(polyGeometry, polyMaterial);
    scene.add(myPoly);  
  }

}

function randColorPolyLine (poly, index, array)
{
  var clr = getRandomColor();

  if ((polyCounter ==34) /*|| (polyCounter % 2 == 0) */ )
  {
    var points = [];
    var geoPoints =[];
    for (var i=0; i< poly.length; i++)
    {
      var tempV = new THREE.Vector3(poly[i][0],poly[i][1], poly[i][2]).normalize().multiplyScalar(sphereRadius);
      points.push(tempV.clone());

      var geoPoint = vector3toLonLat(tempV);
      geoPoints.push(geoPoint);
      //if( (i == 2 ) || (i== 10) || (i ==20) || (i==30 ) || (i== 60) || (i== 150) || (i== poly.length - 1))
      {
      // drawLabelAt(tempV, i.toString());
      }

    }



    //var hulls = d3.polygonHull(geoPoints);
   //var hulls = geoPoints;


   points.push(points[0]);
   geoPoints.push(vector3toLonLat(points[0].clone()));
   

   

  for (var i=0; i< points.length-1; i++)
  {
    var start = points[i];
    var end =  points[i+1 ];
    var ret = setArcGetGeoPoints(start, end, 6, clr);
    scene.add(ret[0]);
  }
  

  var ctr = findCenterPoint(points);
  drawLabelAt(ctr.normalize().multiplyScalar(sphereRadius), 'c' + polyCounter.toString());


  

  
  var geoPolyformat = {type: "Polygon", coordinates: [geoPoints]};

  
      
      geometry.computeFaceNormals();

      for ( var j = 0; j < geometry.faces.length; j ++ )
      {
        var normalGeo = vector3toLonLat (geometry.faces[j].normal);
        //var idx = geometry.faces[j].a;
       // var normalGeo = vector3toLonLat (geometry.vertices[idx]);
        if (d3.geoContains(geoPolyformat, normalGeo) )
       // if (d3.polygonContains(hulls, normalGeo) )
        {
          geometry.faces[ j ].color.setHex(  0xffff00 );
           //geometry.faces.splice(j, 1) ;
        }
    
      }
      //geometry.elementsNeedUpdate = true;///////////////
      geometry.colorsNeedUpdate = true;
      
      
      
  }
  polyCounter++;
  
  
}

// split along the +- 180 lontitude line
function splitPolygon (geoPts)
{
  var retPolys = []
  
}


function  PointInPoly(polyPoints, L)
{
  var x = L[0], y = L[1];

  var inside = false;

  var intersections = 0;

  var ss;

  for (var i = 0, j = polyPoints.length -1; i < polyPoints.length; j = i++)
   {

    var xi = polyPoints[i][0], yi = polyPoints[i][1]; var xj = polyPoints[j][0], yj = polyPoints[j][1];
    if (yj == yi && yj == y && x > Math.min(xj, xi) && x < Math.max(xj, xi)) 
    { // Check if point is on an horizontal polygon boundary
     return true;

    }

    if (y > Math.min(yj, yi) && y <= Math.max(yj, yi) && x <= Math.max(xj, xi) && yj != yi)
    {
      ss = (y - yj) * (xi - xj) / (yi - yj) + xj;
      if (ss == x) 
      { // Check if point is on the polygon boundary (other than horizontal)
        return true;
      }

      if (xj == xi || x <= ss) 
      {
        intersections++;
      } 
    }
  }

  // If the number of edges we passed through is odd, then it’s in the polygon.

  if (intersections % 2 != 0) 
  {
    return true;
  } 
  else
  {
    return false;
  }
}



function randColorPoly2 (poly, index, array)
{
   if (poly.length < 3)
   {
     return
   }

   var points = [];
   for (var i=0; i< poly.length; i++)
   {
    var tempV = new THREE.Vector3(poly[i][0],poly[i][1], poly[i][2]).normalize().multiplyScalar(sphereRadius);
    points.push(tempV);
   }
   var polyCenter = findCenterPoint(points);

   //if ((index > 10) && (index < 13))
   //{
     spot(polyCenter.normalize().multiplyScalar(sphereRadius), 'pink');
   
    //drawPolygon2(points, polyCenter, getRandomColor(), true);

    drawPolygon3(points, getRandomColor(), false);
  //}
}

function drawPolygon( abcde, theColor)
{
  //abcde are points (vertex) in vector3 format.
  // walk from a to b to c to d to e... and back to a. After every degree create an additional point (lat, lon).
  var geoJsonArray =[];
  var polyArray =[];

  var smoothness = 8;
  for (var i=0; i< abcde.length-1; i++)
  {
  var smoothness = 8;
  var arcAndGeoPoints = setArcGetGeoPoints(abcde[i], abcde[i+1], smoothness, theColor);
     // scene.add(arcAndGeoPoints[0]);
      polyArray = polyArray.concat(arcAndGeoPoints[1]);
  }
  var closing = setArcGetGeoPoints(abcde[abcde.length-1], abcde[0], smoothness, theColor);
 // scene.add(closing[0]);
  polyArray = polyArray.concat(closing[1]);
  geoJsonArray.push(polyArray);

  //draw a polygon with color
const polyMesh = new THREE.Mesh(
  //new THREE.ConicPolygonGeometry(polygonGeoJson, 0, sphereRadius, false, true, false ),
  new THREE.ConicPolygonBufferGeometry(geoJsonArray, 0, sphereRadius, false, true, false ),
 
  new THREE.MeshBasicMaterial({ color: theColor })
);
scene.add(polyMesh);
}

/***
 *  sides: THREE.Vector3 arrays of 3d point forming the outsides of the polygon.
 *  center: a THREE.Vector3 3d point inside the polygon, does not have to be exactly the center point.
 * sidesCounterClockWise: weather the side point array goes couterclockwise or not.
 */
function drawPolygon2 (sides, center, theColor, sidesCounterClockWise = true)
{
  /***
   * idea:  connect the central point to every out edge point, to form trianles, then sub divide each triangle to more smaller triangles to form a mesh.
   */

  const polyGeometry = new THREE.Geometry();
  polyGeometry.vertices.push(center.normalize().multiplyScalar(sphereRadius));
   var c = 0;

   if (false == sides[0].equals(sides[sides.length-1]))
   {
     sides.push(sides[0]);
   }

  for (var i=0; i < sides.length-1; i++)
  {
      var smooth = GetSmoothness(sides[i], sides[i+1]);
      var sectionPoints = getArcPoints(sides[i], sides[i+1], smooth);
      for (var j =0; j< smooth - 1; j++)
      {
         var cordSmooth =  GetSmoothness (center, sectionPoints[j]);
         var cordPointsA = getArcPoints(center, sectionPoints[j], cordSmooth);
         var cordPointsB = getArcPoints(center, sectionPoints[j+1], cordSmooth);
         for (var k =0; k < cordSmooth; k++)
         {
          polyGeometry.vertices.push(cordPointsA[k].normalize().multiplyScalar(sphereRadius));
          c++;
          polyGeometry.vertices.push(cordPointsB[k].normalize().multiplyScalar(sphereRadius));
          c++;

          if (true == sidesCounterClockWise)
          {
            if (k == 0)
            {
              polyGeometry.faces.push( new THREE.Face3 (0, c-1, c));
            }
            else
            {
              polyGeometry.faces.push( new THREE.Face3 (c-3, c -1, c- 2));
              polyGeometry.faces.push( new THREE.Face3 (c-2, c -1, c));
            }

          }
          else
          {
            if (k == 0)
            {
              polyGeometry.faces.push( new THREE.Face3 (0, c, c-1));
            }
            else
            {
              polyGeometry.faces.push( new THREE.Face3 (c-3, c -2, c));
              polyGeometry.faces.push( new THREE.Face3 (c-3, c, c -1));
            }
          }

        }
      }
  }
 


  const polyMaterial = new THREE.MeshBasicMaterial(
    {color: theColor,
      /* wireframe: true, */
      vertexColors: THREE.FaceColors
      
      
      
    });

  const myPoly = new THREE.Mesh(polyGeometry, polyMaterial);
  scene.add(myPoly);
}



function drawPolygon3(sides, theColor, sidesCounterClockWise = true)
{
  /***
   * idea:  connect the central point to every out edge point, to form trianles, then sub divide each triangle to more smaller triangles to form a mesh.
   */


  var geoPoints =[];
  for (var i=0; i< sides.length; i++)
  {
    
    
    var geoPoint = vector3toLonLat(sides[i].clone());
    geoPoints.push(geoPoint);
  }
  geoPoints.push(geoPoints[0]);

  var geoPolyformat = {type: "Polygon", coordinates: [geoPoints]};
   
  var geoCenter = d3.geoCentroid(geoPolyformat);
  var center = lonLatToVector3(geoCenter[0], geoCenter[1]);



  const polyGeometry = new THREE.Geometry();
  polyGeometry.vertices.push(center.normalize().multiplyScalar(sphereRadius));
   var c = 0;

   if (false == sides[0].equals(sides[sides.length-1]))
   {
     sides.push(sides[0]);
   }

  for (var i=0; i < sides.length-1; i++)
  {
      var smooth = GetSmoothness(sides[i], sides[i+1]);
      var sectionPoints = getArcPoints(sides[i], sides[i+1], smooth);
      for (var j =0; j< smooth - 1; j++)
      {
         var cordSmooth =  GetSmoothness (center, sectionPoints[j]);
         var cordPointsA = getArcPoints(center, sectionPoints[j], cordSmooth);
         var cordPointsB = getArcPoints(center, sectionPoints[j+1], cordSmooth);
         for (var k =0; k < cordSmooth; k++)
         {
          polyGeometry.vertices.push(cordPointsA[k].normalize().multiplyScalar(sphereRadius));
          c++;
          polyGeometry.vertices.push(cordPointsB[k].normalize().multiplyScalar(sphereRadius));
          c++;

          if (true == sidesCounterClockWise)
          {
            if (k == 0)
            {
              polyGeometry.faces.push( new THREE.Face3 (0, c-1, c));
            }
            else
            {
              polyGeometry.faces.push( new THREE.Face3 (c-3, c -1, c- 2));
              polyGeometry.faces.push( new THREE.Face3 (c-2, c -1, c));
            }

          }
          else
          {
            if (k == 0)
            {
              polyGeometry.faces.push( new THREE.Face3 (0, c, c-1));
            }
            else
            {
              polyGeometry.faces.push( new THREE.Face3 (c-3, c -2, c));
              polyGeometry.faces.push( new THREE.Face3 (c-3, c, c -1));
            }
          }

        }
      }
  }
 


  const polyMaterial = new THREE.MeshBasicMaterial(
    {color: theColor,
      /* wireframe: true, */
      vertexColors: THREE.FaceColors
      
      
      
    });

  const myPoly = new THREE.Mesh(polyGeometry, polyMaterial);
  
  scene.add(myPoly);
  
  polyGeometry.computeFaceNormals();

  for ( var j = 0; j < polyGeometry.faces.length; j ++ )
  {
    var normalGeo = vector3toLonLat (polyGeometry.faces[j].normal);
    //var idx = geometry.faces[j].a;
    // var normalGeo = vector3toLonLat (geometry.vertices[idx]);
    if (false == d3.geoContains(geoPolyformat, normalGeo) )
    // if (d3.polygonContains(hulls, normalGeo) )
    {
      //polyGeometry.faces[ j ].color.setHex(  0xffffff );
        polyGeometry.faces.splice(j, 1) ;
    }

  }
  geometry.elementsNeedUpdate = true;///////////////
  polyGeometry.colorsNeedUpdate = true;
  

  
  }


////////////////
function vector3toLonLat( vector3 )
{

    vector3.normalize();

    //longitude = angle of the vector around the Y axis
    //-( ) : negate to flip the longitude (3d space specific )
    //- PI / 2 to face the Z axis
    var lng = -( Math.atan2( -vector3.z, -vector3.x ) ) - Math.PI / 2;

    //to bind between -PI / PI
    if( lng < - Math.PI )lng += Math.PI * 2;

    //latitude : angle between the vector & the vector projected on the XZ plane on a unit sphere

    //project on the XZ plane
    var p = new THREE.Vector3( vector3.x, 0, vector3.z );
    //project on the unit sphere
    p.normalize();

    //commpute the angle ( both vectors are normalized, no division by the sum of lengths )
    var lat = Math.acos( p.dot( vector3 ) );

    //invert if Y is negative to ensure teh latitude is comprised between -PI/2 & PI / 2
    if( vector3.y < 0 ) lat *= -1;

    return [ lng*(180.0/Math.PI),lat*(180.0/Math.PI) ];

}

function vector3toLonLatRadians( vector3 )
{

    vector3.normalize();

    //longitude = angle of the vector around the Y axis
    //-( ) : negate to flip the longitude (3d space specific )
    //- PI / 2 to face the Z axis
    var lng = -( Math.atan2( -vector3.z, -vector3.x ) ) - Math.PI / 2;

    //to bind between -PI / PI
    if( lng < - Math.PI )lng += Math.PI * 2;

    //latitude : angle between the vector & the vector projected on the XZ plane on a unit sphere

    //project on the XZ plane
    var p = new THREE.Vector3( vector3.x, 0, vector3.z );
    //project on the unit sphere
    p.normalize();

    //commpute the angle ( both vectors are normalized, no division by the sum of lengths )
    var lat = Math.acos( p.dot( vector3 ) );

    //invert if Y is negative to ensure teh latitude is comprised between -PI/2 & PI / 2
    if( vector3.y < 0 ) lat *= -1;

    return [ lng,lat ];

}


function vector3toLatLon( vector3 )
{

    vector3.normalize();

    //longitude = angle of the vector around the Y axis
    //-( ) : negate to flip the longitude (3d space specific )
    //- PI / 2 to face the Z axis
    var lng = -( Math.atan2( -vector3.z, -vector3.x ) ) - Math.PI / 2;

    //to bind between -PI / PI
    if( lng < - Math.PI )lng += Math.PI * 2;

    //latitude : angle between the vector & the vector projected on the XZ plane on a unit sphere

    //project on the XZ plane
    var p = new THREE.Vector3( vector3.x, 0, vector3.z );
    //project on the unit sphere
    p.normalize();

    //commpute the angle ( both vectors are normalized, no division by the sum of lengths )
    var lat = Math.acos( p.dot( vector3 ) );

    //invert if Y is negative to ensure teh latitude is comprised between -PI/2 & PI / 2
    if( vector3.y < 0 ) lat *= -1;

    return [lat*(180.0/Math.PI), lng*(180.0/Math.PI) ];

}

/**
 * converts a XYZ vector3 to longitude latitude (Direct Polar)
 * @param lng longitude, in degree ( -180 to + 180)
 * @param lat latitude, in degree ( -90 to + 50)
 * @param vector3 optional output vector3
 * @returns a unit vector of the 3d position
 */
function lonLatToVector3( lng, lat, out )
{
    lng = lng*Math.PI/180;
    lat = lat*Math.PI/180;

    out = out || new THREE.Vector3();

    //flips the Y axis
    lat = Math.PI / 2 - lat;

    //distribute to sphere
    out.set(
                Math.sin( lat ) * Math.sin( lng ),
                Math.cos( lat ),
                Math.sin( lat ) * Math.cos( lng )
    );

    return out;

}

function getCrossLatFromLonLat (lon0, lat0, lon1, lat1, lont)
{
  if (Math.abs(lat1 - lat0) < 0.01)
  {
    return (lat1 + lat0)/2.0;
  }
 
  var est =  lat0 + (lat1 -lat0) *( lont  - lon0)/ ( lon1 -lon0);

  var v0 = lonLatToVector3(lon0, lat0);
  var v1 = lonLatToVector3(lon1, lat1);
  v0.cross(v1);

  var l0 = lonLatToVector3(lont, lat0);
  var l1 = lonLatToVector3(lont, lat1);
  l0.cross(l1);

  var x1 = v0.clone().cross(l0);
  var x2 = l0.clone().cross(v0);

  var lonlat1 = vector3toLonLat(x1);
  var lonlat2 = vector3toLonLat(x2);
 
  if (Math.abs(lonlat1[1] - est) < Math.abs(lonlat2[1] -est) )
  {
    return lonlat1[1];
  }
  else
  return lonlat2[1];


}


function getCross180LatFromLonLat (lon0, lat0, lon1, lat1)
{
  if (Math.abs(lat1 - lat0) < 0.01)
  {
    return (lat1 + lat0)/2.0;
  }

  
  //return getCrossLatFromLonLat(lon0, lat0, lon1, lat1, 180);

 var est =  lat0 + (lat1 -lat0) *( 180  - Math.abs(lon0) )/ ( 180  - Math.abs(lon0) + 180 - Math.abs(lon1));

 var v0 = lonLatToVector3(lon0, lat0);
  var v1 = lonLatToVector3(lon1, lat1);
  v0.cross(v1);

  var l0 = lonLatToVector3(180, lat0);
  var l1 = lonLatToVector3(180, lat1);
  l0.cross(l1);

  var x1 = v0.clone().cross(l0);
  var x2 = l0.clone().cross(v0);

  var lonlat1 = vector3toLonLat(x1);
  var lonlat2 = vector3toLonLat(x2);
 
  if (Math.abs(lonlat1[1] - est) < Math.abs(lonlat2[1] -est) )
  {
    return lonlat1[1];
  }
  else
  return lonlat2[1];

  //https://gis.stackexchange.com/questions/18562/how-can-i-make-a-polyline-wrap-around-the-world
  // original post is in Cartesian coordinates
 
  //(x0, y0, z0) = (cos(lon0)*sin(lat0), sin(lon0)*sin(lat0), cos(lat0))
  
   var x0 = Math.cos(lon0*Math.PI/180)*Math.sin(lat0*Math.PI/180);
   var y0 = Math.sin(lon0*Math.PI/180) * Math.sin(lat0*Math.PI/180);
   var z0 = Math.cos(lat0*Math.PI/180);

   var x1 = Math.cos(lon1*Math.PI/180)*Math.sin(lat1*Math.PI/180);
   var y1 = Math.sin(lon1*Math.PI/180) * Math.sin(lat1*Math.PI/180);
   var z1 = Math.cos(lat1*Math.PI/180);

   var t = y1 / (y1 - y0);

   //(x, y, z) = (t * x0 + (1-t) * x1, 0, t * z0 + (1-t) * z1)
   var x = t * x0 + (1-t) * x1;
   var z =  t * z0 + (1-t) * z1;
   
   //lat2 = ATan(z/x).
   var lat2 = Math.atan(z/x)*180/Math.PI;
   return lat2;






  // based on   
  //https://gis.stackexchange.com/questions/18562/how-can-i-make-a-polyline-wrap-around-the-world
  // original post is in Cartesian coordinates, not Three.js's, so  bit conversion. 
  /**
    Cartesin:   z                             WebGL THREE.JS:           y
                |                                                       |
                |                                                       |
                --------y                                                --------- x
               /                                                       /
              /                                                       /
            x                                                        z

  var v0 = lonLatToVector3 (lon0, lat0);
  var v1 = lonLatToVector3(lon1, lat1);

  var t = v1.z/(v1.x - v0.x);
  var z = t*v0.z + (1-t)*v1.z;
  var y = t*v0.y + (1-t)*v1.y

  var lat2 = Math.atan(y/z)*180/Math.PI;

  return lat2;
  */


}

function slicePoly (poly, wlont)
{
  var ret =[];
  var minMax = polyMinMaxLon (poly);
  if (minMax[1] - minMax[0] <=wlont)
  {
    ret.push(poly);
    return ret;
  }
  else
  {
    var polyArray = cutAlongLont (poly, minMax[0] + (minMax[1] - minMax[0])/2);
    for (var i=0; i < polyArray.length; i++)
    {
       var newPolyArray = slicePoly(polyArray[i], wlont);
       ret = ret.concat(newPolyArray);

    }
    return ret;
  }
}

function polyMinMaxLon (poly)
{
  var min = poly[0][0];
  var max = min;
  for (var i=1; i<poly.length; i++)
  {
    if (poly[i][0] < min)
    {
      min = poly[i][0];
    }
    if (poly[i][0] > max)
    {
      max = poly[i][0];
    }
  }

  return [min, max];
}

// the poly arrray in  geo point.
function cutAlong180 (poly)
{
  var ret = [];
  var crossIndice =[];   // contain [beforeIdx, afterIdx, crossLat]


  var counter =0;  // how many times crossed the line

  for (var i=0; i < poly.length-1; i++)
  {
    if (Math.abs(poly[i][0] - poly[i+1][0]) > 180)
    {
      counter++;
      var crossLat = getCross180LatFromLonLat(poly[i][0], poly[i][1], poly[i+1][0], poly[i+1][1]);
      var cross = [i, i+1, crossLat];
      if ((crossIndice.length == 0) || (crossLat <= crossIndice[crossIndice.length-1][2]) )
      {
        crossIndice.push(cross);
      }
      else
      {
        for (var j=0; j< crossIndice.length; j++)
        {
          if (crossLat > crossIndice[j][2])
          {
            crossIndice.splice(j, 0, cross);
            break; 
          }
        }
        
      }
    }
  }

  // check end point to start point
  var end = poly.length -1;
  if (Math.abs(poly[end][0] - poly[0][0]) > 180)
  {
    counter++;
    var crossLat2 = getCross180LatFromLonLat(poly[end][0], poly[End][1], poly[0][0], poly[0][1]);
    var cross2 = [end, 0, crossLat2];
    if ((crossIndice.length == 0) || (crossLat2 <= crossIndice[crossIndice.length-1][2]) )
    {
      crossIndice.push(cross2);
    }
    else
    {
      for (var j=0; j< crossIndice.length; j++)
      {
        if (crossLat2 > crossIndice[j][2])
        {
          crossIndice.splice(j, 0, cross2);
          break; 
        }
      }
      
    }
  }


  if (counter == 0)
  {
    ret.push(poly);
    return ret;
  }
  else
  {
    // split into two poly, and recursively keep spliting
    var rightPoly =[];  // negative lon
     var rstart = [-180, crossIndice[0][2]];
     rightPoly.push(rstart);

     // then copy from after index of top cross all the way to the before index of the 2nd cross
     if (crossIndice[1][0] >= crossIndice[0][1])
     {
       for (var k = crossIndice[0][1];k <= crossIndice[1][0]; k++)
       {
         rightPoly.push(poly[k]);
       }
     }
     else
     {
       // rounded back to o, 1, 2, ...
       for (var k = crossIndice[0][1]; k <= poly.length -1; k++)
       {
         rightPoly.push(poly[k]);
       }

       for (var k = 0; k < crossIndice[1][0]; k++)
       {
         rightPoly.push(poly[k]);
       }
     }

     var rend = [ -180, crossIndice[1][2] ];
     rightPoly.push (rend);


     var leftPoly = [];
     var lstart = [180, crossIndice[1][2]];
     leftPoly.push(lstart);

     // then copy from after index of 2nd top cross all the to the before index of the 1st top cross
     if (crossIndice[0][0] >= crossIndice[1][1])
     {
       for (var k = crossIndice[1][1]; k  <= crossIndice[0][0]; k++ )
       {
         leftPoly.push(poly[k]);
       }
     }
     else
     {
       for (var k= crossIndice[1][1]; k <= poly.length -1; k++)
       {
         leftPoly.push(poly[k]);

       }
       for (var k=0; k <= crossIndice[0][0]; k++)
       {
        leftPoly.push(poly[k]);
       }
     }

     var lend = [180, crossIndice[0][2]];
     leftPoly.push(lend);

     return cutAlong180(leftPoly).concat(cutAlong180(rightPoly));





  }



}

function crossedLont (leftLon, crossLon, rightLon)
{
   if ( ( ( leftLon < crossLon) && (rightLon > crossLon) ) ||   ((rightLon < crossLon) && (leftLon > crossLon)))
    {
      return true;
    }
    return false;

}

// cut along a latitude, the poly is not cross 180
function cutAlongLont (poly, lont)
{
  var ret = [];
  var crossIndice =[];   // contain [beforeIdx, afterIdx, crossLat]


  var counter =0;  // how many times crossed the line

  for (var i=0; i < poly.length-1; i++)
  {
    if ( crossedLont(poly[i][0], lont, poly[i+1][0]) )
    {
      counter++;
      var crossLat = getCrossLatFromLonLat(poly[i][0], poly[i][1], poly[i+1][0], poly[i+1][1], lont);
      var cross = [i, i+1, crossLat];
      if ((crossIndice.length == 0) || (crossLat <= crossIndice[crossIndice.length-1][2]) )
      {
        crossIndice.push(cross);
      }
      else
      {
        for (var j=0; j< crossIndice.length; j++)
        {
          if (crossLat > crossIndice[j][2])
          {
            crossIndice.splice(j, 0, cross);
            break; 
          }
        }
        
      }
    }
  }

  // check end point to start point
  var end = poly.length -1;
  if (crossedLont(poly[end][0], lont, poly[0][0]))
  {
    counter++;
    var crossLat2 = getCrossLatFromLonLat(poly[end][0], poly[End][1], poly[0][0], poly[0][1], lont);
    var cross2 = [end, 0, crossLat2];
    if ((crossIndice.length == 0) || (crossLat2 <= crossIndice[crossIndice.length-1][2]) )
    {
      crossIndice.push(cross2);
    }
    else
    {
      for (var j=0; j< crossIndice.length; j++)
      {
        if (crossLat2 > crossIndice[j][2])
        {
          crossIndice.splice(j, 0, cross2);
          break; 
        }
      }
      
    }
  }


  if (counter == 0)
  {
    ret.push(poly);
    return ret;
  }
  else
  {
    // split into two poly, and recursively keep spliting
    var rightPoly =[];  // 
     var rstart = [lont, crossIndice[0][2]];
     rightPoly.push(rstart);

     // then copy from after index of top cross all the way to the before index of the 2nd cross
     if (crossIndice[1][0] >= crossIndice[0][1])
     {
       for (var k = crossIndice[0][1];k <= crossIndice[1][0]; k++)
       {
         rightPoly.push(poly[k]);
       }
     }
     else
     {
       // rounded back to o, 1, 2, ...
       for (var k = crossIndice[0][1]; k <= poly.length -1; k++)
       {
         rightPoly.push(poly[k]);
       }

       for (var k = 0; k < crossIndice[1][0]; k++)
       {
         rightPoly.push(poly[k]);
       }
     }

     var rend = [ lont, crossIndice[1][2] ];
     rightPoly.push (rend);


     var leftPoly = [];
     var lstart = [lont, crossIndice[1][2]];
     leftPoly.push(lstart);

     // then copy from after index of 2nd top cross all the to the before index of the 1st top cross
     if (crossIndice[0][0] >= crossIndice[1][1])
     {
       for (var k = crossIndice[1][1]; k  <= crossIndice[0][0]; k++ )
       {
         leftPoly.push(poly[k]);
       }
     }
     else
     {
       for (var k= crossIndice[1][1]; k <= poly.length -1; k++)
       {
         leftPoly.push(poly[k]);

       }
       for (var k=0; k <= crossIndice[0][0]; k++)
       {
        leftPoly.push(poly[k]);
       }
     }

     var lend = [lont, crossIndice[0][2]];
     leftPoly.push(lend);

     return cutAlongLont(leftPoly, lont).concat(cutAlongLont(rightPoly, lont));





  }



}

/**
 * Find the bounding regtangle and uses the mid point of the rectangle in terms of lon. and lat.
 * 
 * @param polySides  Vecter3 array composing the sides of the polygon.
 */
function findCenterPoint (polySides)
{
  var minLat, maxLat, minLon, maxLon;

  var init = vector3toLonLat(polySides[0]);
  minLon = maxLon = init[0];
  minLat = maxLat = init[1];

  for (var i=1; i<polySides.length; i++)
  {
    var temp = vector3toLonLat(polySides[i]);
    var lon = temp[0];
    var lat = temp[1];
    if (lon < minLon)
    {
      minLon = lon;
    }
    if (lon > maxLon)
    {
      maxLon = lon;
    }
    if (lat < minLat)
    {
      minLat = lat;
    }
    if (lat > maxLat)
    {
      maxLat = lat;
    }
  }

  var midLat = (minLat + maxLat)/2.0;

  //we have to take care of +180 and -180 scenarios
  var midLon;
  // all positives or all negative
  if  (((minLon >=0) && (maxLon >=0)) || ((minLon <=0) && (maxLon <=0)))
  {
   midLon = (minLon + maxLon)/2.0;
  }
  else
  {
    // one positive and one negative, which mean minLon is negative.
    if (Math.abs(minLon) + Math.abs(maxLon) <= 180.0)
    {
      midLon = (minLon + maxLon)/2.0;
    }
    else
    {
      var reverseMid = ((180 - Math.abs(minLon) ) + (180 -Math.abs(maxLon)))/2;
      if (Math.abs(minLon) < Math.abs(maxLon))
      {
        midLon = minLon - reverseMid;
      }
      else
      {
        midLon = maxLon + reverseMid;
      }
    }
  }
  //return lonLatToVector3(midLon*Math.PI/180, midLat*Math.PI/180);
  return lonLatToVector3(midLon, midLat);
}


function getRandomColor() {
  var letters = '0123456789ABCDEF';
  var color = '#';
  for (var i = 0; i < 6; i++) {
  color += letters[Math.floor(Math.random() * 16)];
  }
  return color;
  }

function convertFlatCoordsToSphereCoords(x, y) {
  // Calculate the relative 3d coordinates using Mercator projection relative to the radius of the globe.
  // Convert latitude and longitude on the 90/180 degree axis.
  let latitude = ((x - globeWidth) / globeWidth) * -180
  let longitude = ((y - globeHeight) / globeHeight) * -90
  latitude = (latitude * Math.PI) / 180 //(latitude / 180) * Math.PI
  longitude = (longitude * Math.PI) / 180 //(longitude / 180) * Math.PI // Calculate the projected starting point
  const radius = Math.cos(longitude) * globeRadius
  const targetX = Math.cos(latitude) * radius
  const targetY = Math.sin(longitude) * globeRadius
  const targetZ = Math.sin(latitude) * radius

  
 

  return new THREE.Vector3(targetX, targetY, targetZ);
}

render();


function resizeRendererToDisplaySize(renderer) {
  const canvas = renderer.domElement;
  const width = canvas.clientWidth;
  const height = canvas.clientHeight;
  const needResize = canvas.width !== width || canvas.height !== height;
  if (needResize) {
    renderer.setSize(width, height, false);
  }
  return needResize;
}



function render() {

  if (resizeRendererToDisplaySize(renderer)) {
    const canvas = renderer.domElement;
    camera.aspect = canvas.clientWidth / canvas.clientHeight;
    camera.updateProjectionMatrix();
  }
  sphere.updateWorldMatrix(true, false);

  ///
  normalMatrix.getNormalMatrix(camera.matrixWorldInverse);
  camera.getWorldPosition(cameraPosition);
  labels.forEach((info, ndx) => {
    const {elem, meshPoint} = info;
    
    meshPoint.updateWorldMatrix(true, false);
    meshPoint.getWorldPosition(tempV);
    myV.copy(tempV);
    // 
    cameraToPoint.copy(myV);
    // get the normalized screen coordinate of that position
    // x and y will be in the -1 to +1 range with x = -1 being
    // on the left and y = -1 being on the bottom
    tempV.project(camera);

    //////////////////////////// make label invisible if on the other side of the sphere
    // Orient the position based on the camera's orientation.
    // Since the sphere is at the origin and the sphere is a unit sphere
    // this gives us a camera relative direction vector for the position.
    
    myV.applyMatrix3(normalMatrix);
    

    // compute the direction to this position from the camera
    
    cameraToPoint.applyMatrix4(camera.matrixWorldInverse).normalize();

    // get the dot product of camera relative direction to this position
    // on the globe with the direction from the camera to that point.
    // -1 = facing directly towards the camera
    // 0 = exactly on tangent of the sphere from the camera
    // > 0 = facing away
    const dot = myV.dot(cameraToPoint);

    // if the orientation is not facing us hide it.
    if (dot > settings.maxVisibleDot) {
      elem.style.display = 'none';
      
    }
    else {

       // restore the element to its default display style
       elem.style.display = '';
    ////////////////////////////////////////////////

    // convert the normalized position to CSS coordinates
    const x = (tempV.x *  .5 + .5) * canvas.clientWidth;
    const y = (tempV.y * -.5 + .5) * canvas.clientHeight;
    
   /* 
   const x = ((tempV.x *  .5 + .5) * canvas.clientWidth)%canvas.clientWidth;
   const y = ((tempV.y * -.5 + .5) * canvas.clientHeight)%canvas.clientHeight;
   */

    // move the elem to that position
    elem.style.transform = `translate(-50%, -50%) translate(${x}px,${y}px)`;
    }
  });
  ////



  requestAnimationFrame(render);
  renderer.render(scene, camera);
}
